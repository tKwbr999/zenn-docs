---
title: ""
emoji: "ğŸ‘"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: []
published: false
---

# Reactã‚’åˆ©ç”¨ã—ãŸãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã§ã®èªè¨¼å®Ÿè£…å®Œå…¨ã‚¬ã‚¤ãƒ‰

## ã¯ã˜ã‚ã«

ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰é–‹ç™ºã«ãŠã„ã¦ã€èªè¨¼æ©Ÿèƒ½ã®å®Ÿè£…ã¯æœ€ã‚‚é‡è¦ã‹ã¤è¤‡é›‘ãªèª²é¡Œã®ä¸€ã¤ã§ã™ã€‚ç‰¹ã«Reactã‚’ä½¿ç”¨ã—ãŸSPAï¼ˆSingle Page Applicationï¼‰ã§ã¯ã€å¾“æ¥ã®ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã¨ã¯ç•°ãªã‚‹ã‚¢ãƒ—ãƒ­ãƒ¼ãƒãŒå¿…è¦ã¨ãªã‚Šã¾ã™ã€‚

ã“ã®è¨˜äº‹ã§ã¯ã€Reactç’°å¢ƒã§ã®èªè¨¼å®Ÿè£…ã«ã¤ã„ã¦ã€åŸºç¤çŸ¥è­˜ã‹ã‚‰å®Ÿè£…æ–¹æ³•ã€ãƒ†ã‚¹ãƒˆã€ä¿å®ˆã¾ã§åŒ…æ‹¬çš„ã«è§£èª¬ã—ã¾ã™ã€‚ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚’ç¢ºä¿ã—ã¤ã¤ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½“é¨“ã‚’æãªã‚ãªã„èªè¨¼ã‚·ã‚¹ãƒ†ãƒ ã®æ§‹ç¯‰ã‚’ç›®æŒ‡ã—ã¾ã—ã‚‡ã†ã€‚

## èªè¨¼ã‚’å®Ÿè£…ã™ã‚‹ä¸Šã§çŸ¥ã£ã¦ãŠãã¹ãçŸ¥è­˜

### èªè¨¼ã¨èªå¯ã®é•ã„

ã¾ãšåŸºæœ¬çš„ãªæ¦‚å¿µã¨ã—ã¦ã€èªè¨¼ï¼ˆAuthenticationï¼‰ã¨èªå¯ï¼ˆAuthorizationï¼‰ã®é•ã„ã‚’ç†è§£ã—ã¾ã—ã‚‡ã†ã€‚

- **èªè¨¼ï¼ˆAuthenticationï¼‰**ï¼šã€Œã‚ãªãŸã¯èª°ã§ã™ã‹ï¼Ÿã€ã¨ã„ã†å•ã„ã«ç­”ãˆã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã€‚ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã¨ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã®æ¤œè¨¼ãªã©ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®èº«å…ƒã‚’ç¢ºèªã™ã‚‹ã€‚
- **èªå¯ï¼ˆAuthorizationï¼‰**ï¼šã€Œã‚ãªãŸã«ã¯ä½•ãŒè¨±å¯ã•ã‚Œã¦ã„ã¾ã™ã‹ï¼Ÿã€ã¨ã„ã†å•ã„ã«ç­”ãˆã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã€‚èªè¨¼æ¸ˆã¿ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«å¯¾ã—ã¦ã€ç‰¹å®šã®ãƒªã‚½ãƒ¼ã‚¹ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹æ¨©é™ã‚’ä¸ãˆã‚‹ã€‚

### èªè¨¼ã®ç¨®é¡

ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰èªè¨¼ã«ã¯ä¸»ã«ä»¥ä¸‹ã®æ‰‹æ³•ãŒã‚ã‚Šã¾ã™ï¼š

1. **ãƒˆãƒ¼ã‚¯ãƒ³ãƒ™ãƒ¼ã‚¹èªè¨¼**
   - JWTãƒˆãƒ¼ã‚¯ãƒ³ï¼ˆJSON Web Tokenï¼‰
   - ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒˆãƒ¼ã‚¯ãƒ³
   - ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³

2. **OAuth/OpenID Connect**
   - Googleãªã©ã®å¤–éƒ¨ã‚µãƒ¼ãƒ“ã‚¹ã«ã‚ˆã‚‹ã‚½ãƒ¼ã‚·ãƒ£ãƒ«èªè¨¼
   - SSOã®å®Ÿè£…

3. **ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒ¬ã‚¹èªè¨¼**
   - Eãƒ¡ãƒ¼ãƒ«/SMSãƒ¯ãƒ³ã‚¿ã‚¤ãƒ ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰
   - ãƒã‚¸ãƒƒã‚¯ãƒªãƒ³ã‚¯

### ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¸Šã®åŸºæœ¬çŸ¥è­˜

èªè¨¼å®Ÿè£…ã«ã‚ãŸã‚Šã€ä»¥ä¸‹ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¸Šã®çŸ¥è­˜ãŒå¿…è¦ã§ã™ï¼š

- **XSSï¼ˆCross-Site Scriptingï¼‰**ï¼šæ‚ªæ„ã®ã‚ã‚‹ã‚¹ã‚¯ãƒªãƒ—ãƒˆãŒæ³¨å…¥ã•ã‚Œã‚‹æ”»æ’ƒ
- **CSRFï¼ˆCross-Site Request Forgeryï¼‰**ï¼šãƒ¦ãƒ¼ã‚¶ãƒ¼ã®æ„å›³ã—ãªã„ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒç™ºè¡Œã•ã‚Œã‚‹æ”»æ’ƒ
- **CORSï¼ˆCross-Origin Resource Sharingï¼‰**ï¼šã‚ªãƒªã‚¸ãƒ³é–“ãƒªã‚½ãƒ¼ã‚¹å…±æœ‰ã®åˆ¶é™
- **HTTPS**ï¼šé€šä¿¡ã®æš—å·åŒ–
- **HttpOnly Cookie**ï¼šJavaScriptã‹ã‚‰ã‚¢ã‚¯ã‚»ã‚¹ã§ããªã„Cookieã®è¨­å®š

## å®Ÿè£…æº–å‚™

### ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã®æ¤œè¨

èªè¨¼ã‚·ã‚¹ãƒ†ãƒ ã‚’å®Ÿè£…ã™ã‚‹å‰ã«ã€ä»¥ä¸‹ã®ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆã‚’æ¤œè¨ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ï¼š

1. **ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã¨ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã®è²¬ä»»åˆ†æ‹…**
   - ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãŒãƒˆãƒ¼ã‚¯ãƒ³ç”Ÿæˆã¨æ¤œè¨¼ã‚’æ‹…å½“
   - ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã¯ãƒˆãƒ¼ã‚¯ãƒ³ã®ä¿å­˜ã¨åˆ©ç”¨ã‚’æ‹…å½“

2. **çŠ¶æ…‹ç®¡ç†ã®é¸æŠ**
   - Contextã«ã‚ˆã‚‹ç®¡ç†
   - Reduxãªã©ã®çŠ¶æ…‹ç®¡ç†ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ä½¿ç”¨
   - React Queryã®ã‚ˆã†ãªè§£æ±ºç­–

3. **ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°è¨­è¨ˆ**
   - ä¿è­·ã•ã‚ŒãŸãƒ«ãƒ¼ãƒˆï¼ˆProtected Routesï¼‰ã®å®Ÿè£…
   - ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆãƒ­ã‚¸ãƒƒã‚¯ã®è¨­è¨ˆ

### å¿…è¦ãªãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®é¸å®š

```bash
# åŸºæœ¬ã®Reactã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³
npx create-react-app my-auth-app --template typescript

# ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°
npm install react-router-dom

# çŠ¶æ…‹ç®¡ç†
npm install @tanstack/react-query  # ã¾ãŸã¯ Redux Toolkit

# èªè¨¼é–¢é€£
npm install jwt-decode axios
```

### ç’°å¢ƒè¨­å®š

é–‹ç™ºç’°å¢ƒã¨æœ¬ç•ªç’°å¢ƒã§é©åˆ‡ã«å‹•ä½œã™ã‚‹ã‚ˆã†ã€ç’°å¢ƒå¤‰æ•°ã‚’è¨­å®šã—ã¾ã™ï¼š

```javascript
// .env.development
REACT_APP_API_URL=http://localhost:8000/api
REACT_APP_AUTH_STORAGE=localStorage

// .env.production
REACT_APP_API_URL=https://api.example.com
REACT_APP_AUTH_STORAGE=cookie
```

## èªè¨¼å®Ÿè£…ã®é¸æŠè‚¢

### 1. JWTã‚’åˆ©ç”¨ã—ãŸèªè¨¼

æœ€ã‚‚ä¸€èˆ¬çš„ãªå®Ÿè£…æ–¹æ³•ã®ä¸€ã¤ãŒJWTï¼ˆJSON Web Tokenï¼‰ã‚’ä½¿ç”¨ã—ãŸèªè¨¼ã§ã™ã€‚

#### ãƒˆãƒ¼ã‚¯ãƒ³ç®¡ç†

```typescript
// src/lib/auth/tokenStorage.ts
export const setToken = (token: string): void => {
  if (process.env.REACT_APP_AUTH_STORAGE === 'localStorage') {
    localStorage.setItem('authToken', token);
  } else {
    // HTTPOnlyã®Cookieã‚’è¨­å®šã™ã‚‹ãŸã‚ã«ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰APIã‚’å‘¼ã³å‡ºã™
    // ç›´æ¥ãƒ•ãƒ­ãƒ³ãƒˆã‹ã‚‰Cookieã‚’æ“ä½œã™ã‚‹ã“ã¨ã¯ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¸Šé¿ã‘ã‚‹
  }
};

export const getToken = (): string | null => {
  if (process.env.REACT_APP_AUTH_STORAGE === 'localStorage') {
    return localStorage.getItem('authToken');
  }
  // Cookieã¯HTTPOnlyè¨­å®šãªã®ã§JavaScriptã‹ã‚‰ã¯ç›´æ¥èª­ã¿å–ã‚Œãªã„
  // ã“ã“ã§ã¯CookieãŒè‡ªå‹•çš„ã«ãƒªã‚¯ã‚¨ã‚¹ãƒˆã«ä»˜ä¸ã•ã‚Œã‚‹å‰æã§ã€ãƒˆãƒ¼ã‚¯ãƒ³ã®å­˜åœ¨ç¢ºèªã®ã¿è¡Œã†
  return document.cookie.includes('authToken') ? 'exists' : null;
};

export const removeToken = (): void => {
  if (process.env.REACT_APP_AUTH_STORAGE === 'localStorage') {
    localStorage.removeItem('authToken');
  } else {
    // HTTPOnlyã®Cookieã‚’å‰Šé™¤ã™ã‚‹ãŸã‚ã«ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰APIã‚’å‘¼ã³å‡ºã™
  }
};
```

#### èªè¨¼ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ

Reactã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’åˆ©ç”¨ã—ã¦ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å…¨ä½“ã§èªè¨¼çŠ¶æ…‹ã‚’ç®¡ç†ã—ã¾ã™ï¼š

```typescript
// src/contexts/AuthContext.tsx
import { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import { getToken, setToken, removeToken } from '../lib/auth/tokenStorage';
import { loginUser, logoutUser, refreshToken } from '../api/authApi';

interface AuthContextType {
  isAuthenticated: boolean;
  user: any | null;
  login: (email: string, password: string) => Promise<void>;
  logout: () => Promise<void>;
  loading: boolean;
  error: string | null;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider = ({ children }: { children: ReactNode }) => {
  const [isAuthenticated, setIsAuthenticated] = useState<boolean>(false);
  const [user, setUser] = useState<any | null>(null);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  // åˆæœŸåŒ–æ™‚ã«ãƒˆãƒ¼ã‚¯ãƒ³ã®å­˜åœ¨ç¢ºèª
  useEffect(() => {
    const initAuth = async () => {
      const token = getToken();
      if (token) {
        try {
          // ãƒˆãƒ¼ã‚¯ãƒ³ã®æ¤œè¨¼ã¨ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã®å–å¾—
          const userData = await refreshToken();
          setUser(userData);
          setIsAuthenticated(true);
        } catch (error) {
          // ãƒˆãƒ¼ã‚¯ãƒ³ãŒç„¡åŠ¹ãªå ´åˆã¯ã‚¯ãƒªã‚¢
          removeToken();
        }
      }
      setLoading(false);
    };

    initAuth();
  }, []);

  // ãƒ­ã‚°ã‚¤ãƒ³é–¢æ•°
  const login = async (email: string, password: string) => {
    setLoading(true);
    setError(null);
    try {
      const { token, user } = await loginUser(email, password);
      setToken(token);
      setUser(user);
      setIsAuthenticated(true);
    } catch (error: any) {
      setError(error.message || 'ãƒ­ã‚°ã‚¤ãƒ³ã«å¤±æ•—ã—ã¾ã—ãŸ');
      throw error;
    } finally {
      setLoading(false);
    }
  };

  // ãƒ­ã‚°ã‚¢ã‚¦ãƒˆé–¢æ•°
  const logout = async () => {
    setLoading(true);
    try {
      await logoutUser();
      removeToken();
      setUser(null);
      setIsAuthenticated(false);
    } catch (error: any) {
      setError(error.message || 'ãƒ­ã‚°ã‚¢ã‚¦ãƒˆã«å¤±æ•—ã—ã¾ã—ãŸ');
    } finally {
      setLoading(false);
    }
  };

  return (
    <AuthContext.Provider value={{ isAuthenticated, user, login, logout, loading, error }}>
      {children}
    </AuthContext.Provider>
  );
};

// ã‚«ã‚¹ã‚¿ãƒ ãƒ•ãƒƒã‚¯
export const useAuth = () => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};
```

#### ä¿è­·ã•ã‚ŒãŸãƒ«ãƒ¼ãƒˆ

èªè¨¼æ¸ˆã¿ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã¿ãŒã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ãƒ«ãƒ¼ãƒˆã‚’å®Ÿè£…ã—ã¾ã™ï¼š

```typescript
// src/components/ProtectedRoute.tsx
import { Navigate, Outlet, useLocation } from 'react-router-dom';
import { useAuth } from '../contexts/AuthContext';

export const ProtectedRoute = () => {
  const { isAuthenticated, loading } = useAuth();
  const location = useLocation();

  if (loading) {
    return <div>Loading...</div>;
  }

  if (!isAuthenticated) {
    // èªè¨¼ã•ã‚Œã¦ã„ãªã„å ´åˆã¯ãƒ­ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã«ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆï¼ˆç¾åœ¨ã®URLã‚’ä¿å­˜ï¼‰
    return <Navigate to="/login" state={{ from: location }} replace />;
  }

  // èªè¨¼æ¸ˆã¿ã®å ´åˆã¯å­ãƒ«ãƒ¼ãƒˆã‚’ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
  return <Outlet />;
};
```

ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°è¨­å®šï¼š

```typescript
// src/App.tsx
import { BrowserRouter, Routes, Route } from 'react-router-dom';
import { AuthProvider } from './contexts/AuthContext';
import { ProtectedRoute } from './components/ProtectedRoute';
import HomePage from './pages/HomePage';
import LoginPage from './pages/LoginPage';
import DashboardPage from './pages/DashboardPage';
import ProfilePage from './pages/ProfilePage';

const App = () => {
  return (
    <AuthProvider>
      <BrowserRouter>
        <Routes>
          <Route path="/" element={<HomePage />} />
          <Route path="/login" element={<LoginPage />} />
          
          {/* ä¿è­·ã•ã‚ŒãŸãƒ«ãƒ¼ãƒˆ */}
          <Route element={<ProtectedRoute />}>
            <Route path="/dashboard" element={<DashboardPage />} />
            <Route path="/profile" element={<ProfilePage />} />
          </Route>
        </Routes>
      </BrowserRouter>
    </AuthProvider>
  );
};

export default App;
```

### 2. React Query ã‚’ä½¿ç”¨ã—ãŸèªè¨¼ç®¡ç†

React Queryã‚’ä½¿ç”¨ã—ã¦èªè¨¼çŠ¶æ…‹ã‚’ç®¡ç†ã™ã‚‹æ–¹æ³•ã‚‚åŠ¹ç‡çš„ã§ã™ï¼š

```typescript
// src/hooks/useAuthQuery.ts
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { getToken, setToken, removeToken } from '../lib/auth/tokenStorage';
import { loginUser, logoutUser, fetchUserProfile } from '../api/authApi';

export const useAuthQuery = () => {
  const queryClient = useQueryClient();

  // ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã®å–å¾—
  const { data: user, isLoading } = useQuery({
    queryKey: ['user'],
    queryFn: fetchUserProfile,
    enabled: !!getToken(), // ãƒˆãƒ¼ã‚¯ãƒ³ãŒå­˜åœ¨ã™ã‚‹å ´åˆã®ã¿å®Ÿè¡Œ
    retry: false,
    staleTime: 1000 * 60 * 5, // 5åˆ†é–“ã‚­ãƒ£ãƒƒã‚·ãƒ¥
  });

  // ãƒ­ã‚°ã‚¤ãƒ³å‡¦ç†
  const loginMutation = useMutation({
    mutationFn: loginUser,
    onSuccess: (data) => {
      setToken(data.token);
      queryClient.setQueryData(['user'], data.user);
    },
  });

  // ãƒ­ã‚°ã‚¢ã‚¦ãƒˆå‡¦ç†
  const logoutMutation = useMutation({
    mutationFn: logoutUser,
    onSuccess: () => {
      removeToken();
      queryClient.setQueryData(['user'], null);
      queryClient.invalidateQueries({ queryKey: ['user'] });
    },
  });

  return {
    user,
    isAuthenticated: !!user,
    isLoading,
    login: loginMutation.mutate,
    logout: logoutMutation.mutate,
    loginError: loginMutation.error,
    logoutError: logoutMutation.error,
  };
};
```

### 3. ã‚½ãƒ¼ã‚·ãƒ£ãƒ«èªè¨¼ï¼ˆOAuthï¼‰

Googleã‚„GitHubãªã©ã®ã‚½ãƒ¼ã‚·ãƒ£ãƒ«èªè¨¼ã‚‚å®Ÿè£…ã§ãã¾ã™ï¼š

```typescript
// src/components/GoogleLogin.tsx
import { useAuth } from '../contexts/AuthContext';

export const GoogleLogin = () => {
  const { isLoading } = useAuth();
  
  const handleGoogleLogin = () => {
    // ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’é–‹ã
    const width = 500;
    const height = 600;
    const left = window.screenX + (window.outerWidth - width) / 2;
    const top = window.screenY + (window.outerHeight - height) / 2;
    
    window.open(
      `${process.env.REACT_APP_API_URL}/auth/google`,
      '_blank',
      `width=${width},height=${height},left=${left},top=${top}`
    );
    
    // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚¤ãƒ™ãƒ³ãƒˆã®ãƒªã‚¹ãƒŠãƒ¼
    window.addEventListener('message', handleAuthMessage, false);
  };
  
  const handleAuthMessage = (event: MessageEvent) => {
    // ã‚ªãƒªã‚¸ãƒ³æ¤œè¨¼
    if (event.origin !== process.env.REACT_APP_API_URL) return;
    
    const { token, user } = event.data;
    if (token && user) {
      // èªè¨¼ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’æ›´æ–°
      setToken(token);
      // ãã®ä»–ã®å¿…è¦ãªå‡¦ç†
    }
    
    // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    window.removeEventListener('message', handleAuthMessage);
  };
  
  return (
    <button 
      onClick={handleGoogleLogin}
      disabled={isLoading}
      className="google-login-button"
    >
      Googleã§ãƒ­ã‚°ã‚¤ãƒ³
    </button>
  );
};
```

## èªè¨¼ãƒ†ã‚¹ãƒˆæ‰‹æ³•

èªè¨¼æ©Ÿèƒ½ã®ãƒ†ã‚¹ãƒˆã¯ä¿¡é ¼æ€§ã®é«˜ã„ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³é–‹ç™ºã«ä¸å¯æ¬ ã§ã™ã€‚

### å˜ä½“ãƒ†ã‚¹ãƒˆ

èªè¨¼ãƒ•ãƒƒã‚¯ã‚„ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®å˜ä½“ãƒ†ã‚¹ãƒˆä¾‹ï¼š

```typescript
// src/contexts/AuthContext.test.tsx
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { AuthProvider, useAuth } from './AuthContext';
import { loginUser, logoutUser } from '../api/authApi';

// APIãƒ¢ãƒƒã‚¯
jest.mock('../api/authApi', () => ({
  loginUser: jest.fn(),
  logoutUser: jest.fn(),
  refreshToken: jest.fn(),
}));

// ãƒˆãƒ¼ã‚¯ãƒ³ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã®ãƒ¢ãƒƒã‚¯
jest.mock('../lib/auth/tokenStorage', () => ({
  getToken: jest.fn(),
  setToken: jest.fn(),
  removeToken: jest.fn(),
}));

// ãƒ†ã‚¹ãƒˆç”¨ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
const TestComponent = () => {
  const { isAuthenticated, login, logout, user } = useAuth();
  
  return (
    <div>
      <div data-testid="auth-status">{isAuthenticated ? 'authenticated' : 'not-authenticated'}</div>
      {user && <div data-testid="user-email">{user.email}</div>}
      <button onClick={() => login('test@example.com', 'password')}>Login</button>
      <button onClick={() => logout()}>Logout</button>
    </div>
  );
};

describe('AuthContext', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });
  
  test('åˆæœŸçŠ¶æ…‹ã¯æœªèªè¨¼', () => {
    const getTokenMock = require('../lib/auth/tokenStorage').getToken;
    getTokenMock.mockReturnValue(null);
    
    render(
      <AuthProvider>
        <TestComponent />
      </AuthProvider>
    );
    
    expect(screen.getByTestId('auth-status')).toHaveTextContent('not-authenticated');
  });
  
  test('ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸæ™‚ã«èªè¨¼çŠ¶æ…‹ãŒæ›´æ–°ã•ã‚Œã‚‹', async () => {
    const loginUserMock = loginUser as jest.Mock;
    loginUserMock.mockResolvedValue({
      token: 'fake-token',
      user: { id: 1, email: 'test@example.com' }
    });
    
    render(
      <AuthProvider>
        <TestComponent />
      </AuthProvider>
    );
    
    userEvent.click(screen.getByText('Login'));
    
    await waitFor(() => {
      expect(screen.getByTestId('auth-status')).toHaveTextContent('authenticated');
      expect(screen.getByTestId('user-email')).toHaveTextContent('test@example.com');
    });
  });
  
  // ä»–ã®ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹...
});
```

### çµ±åˆãƒ†ã‚¹ãƒˆ

ä¿è­·ã•ã‚ŒãŸãƒ«ãƒ¼ãƒˆã®å‹•ä½œã‚’ãƒ†ã‚¹ãƒˆã—ã¾ã™ï¼š

```typescript
// src/App.test.tsx
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import App from './App';
import { getToken } from './lib/auth/tokenStorage';

// å¿…è¦ãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ãƒ¢ãƒƒã‚¯
jest.mock('./lib/auth/tokenStorage');
jest.mock('./api/authApi');

describe('App ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });
  
  test('æœªèªè¨¼ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã¨ãƒ­ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã«ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆã•ã‚Œã‚‹', async () => {
    (getToken as jest.Mock).mockReturnValue(null);
    
    // ãƒ¡ãƒ¢ãƒªãƒ«ãƒ¼ã‚¿ãƒ¼ã‚’ä½¿ç”¨ã—ã¦åˆæœŸãƒ‘ã‚¹ã‚’è¨­å®š
    window.history.pushState({}, '', '/dashboard');
    
    render(<App />);
    
    await waitFor(() => {
      // URLãŒãƒ­ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã«å¤‰æ›´ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª
      expect(window.location.pathname).toBe('/login');
    });
  });
  
  // ä»–ã®ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹...
});
```

### E2Eãƒ†ã‚¹ãƒˆ

Cypress ã‚’ä½¿ç”¨ã—ãŸã‚¨ãƒ³ãƒ‰ãƒ„ãƒ¼ã‚¨ãƒ³ãƒ‰ãƒ†ã‚¹ãƒˆä¾‹ï¼š

```javascript
// cypress/e2e/auth.cy.js
describe('èªè¨¼ãƒ•ãƒ­ãƒ¼', () => {
  it('ãƒ­ã‚°ã‚¤ãƒ³â†’ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã‚¢ã‚¯ã‚»ã‚¹â†’ãƒ­ã‚°ã‚¢ã‚¦ãƒˆã®ãƒ•ãƒ­ãƒ¼ãŒæ­£å¸¸ã«å‹•ä½œã™ã‚‹', () => {
    // ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰APIã‚’ã‚¤ãƒ³ã‚¿ãƒ¼ã‚»ãƒ—ãƒˆ
    cy.intercept('POST', '/api/auth/login', {
      statusCode: 200,
      body: {
        token: 'fake-jwt-token',
        user: { id: 1, email: 'test@example.com' }
      }
    }).as('loginRequest');
    
    // ãƒ­ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã«ã‚¢ã‚¯ã‚»ã‚¹
    cy.visit('/login');
    
    // ãƒ•ã‚©ãƒ¼ãƒ å…¥åŠ›
    cy.get('input[name="email"]').type('test@example.com');
    cy.get('input[name="password"]').type('password123');
    cy.get('button[type="submit"]').click();
    
    // APIãƒªã‚¯ã‚¨ã‚¹ãƒˆã®å®Œäº†ã‚’å¾…ã¤
    cy.wait('@loginRequest');
    
    // ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã«ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆã•ã‚ŒãŸã“ã¨ã‚’ç¢ºèª
    cy.url().should('include', '/dashboard');
    
    // ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ãƒãƒ¼ã«ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ãŒè¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª
    cy.get('[data-testid="user-menu"]').should('contain', 'test@example.com');
    
    // ãƒ­ã‚°ã‚¢ã‚¦ãƒˆå‡¦ç†
    cy.get('[data-testid="logout-button"]').click();
    
    // ãƒˆãƒƒãƒ—ãƒšãƒ¼ã‚¸ã«ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆã•ã‚ŒãŸã“ã¨ã‚’ç¢ºèª
    cy.url().should('eq', Cypress.config().baseUrl + '/');
    
    // ä¿è­·ã•ã‚ŒãŸãƒ«ãƒ¼ãƒˆã«ã‚¢ã‚¯ã‚»ã‚¹ã§ããªã„ã“ã¨ã‚’ç¢ºèª
    cy.visit('/dashboard');
    cy.url().should('include', '/login');
  });
});
```

## èªè¨¼ãƒ‡ãƒ¼ã‚¿ã®ä¿å®ˆæ–¹æ³•

### ãƒˆãƒ¼ã‚¯ãƒ³ã®æ›´æ–°æˆ¦ç•¥

JWTã®ã‚ˆã†ãªæœŸé™ä»˜ããƒˆãƒ¼ã‚¯ãƒ³ã‚’ä½¿ç”¨ã™ã‚‹å ´åˆã€è‡ªå‹•æ›´æ–°ã®ä»•çµ„ã¿ãŒå¿…è¦ã§ã™ï¼š

```typescript
// src/lib/auth/tokenRefresh.ts
import { getToken, setToken } from './tokenStorage';
import { refreshTokenApi } from '../api/authApi';
import jwtDecode from 'jwt-decode';

// ãƒˆãƒ¼ã‚¯ãƒ³ã®æœ‰åŠ¹æœŸé™ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆæœŸé™åˆ‡ã‚Œã®10åˆ†å‰ã«æ›´æ–°ï¼‰
export const isTokenExpiringSoon = (token: string): boolean => {
  try {
    const decoded: any = jwtDecode(token);
    const expiryTime = decoded.exp * 1000; // UNIXã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ï¼ˆãƒŸãƒªç§’ï¼‰
    return Date.now() > expiryTime - 10 * 60 * 1000; // 10åˆ†å‰
  } catch (error) {
    return true; // ãƒ‡ã‚³ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯æœŸé™åˆ‡ã‚Œã¨ã¿ãªã™
  }
};

// è‡ªå‹•ãƒˆãƒ¼ã‚¯ãƒ³æ›´æ–°ã®è¨­å®š
export const setupTokenRefresh = () => {
  // åˆå›ãƒã‚§ãƒƒã‚¯
  checkAndRefreshToken();
  
  // å®šæœŸçš„ãªãƒã‚§ãƒƒã‚¯ï¼ˆ5åˆ†ã”ã¨ï¼‰
  setInterval(checkAndRefreshToken, 5 * 60 * 1000);
};

// ãƒˆãƒ¼ã‚¯ãƒ³ã®ãƒã‚§ãƒƒã‚¯ã¨æ›´æ–°
export const checkAndRefreshToken = async (): Promise<void> => {
  const token = getToken();
  
  if (token && isTokenExpiringSoon(token)) {
    try {
      const { newToken } = await refreshTokenApi();
      setToken(newToken);
    } catch (error) {
      // ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥å¤±æ•—æ™‚ã®å‡¦ç†
      console.error('Token refresh failed:', error);
      // ã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼šãƒ­ã‚°ã‚¢ã‚¦ãƒˆå‡¦ç†ãªã©ã‚’è¡Œã†
    }
  }
};
```

### ã‚¢ã‚¯ã‚»ã‚¹ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ç›£è¦–

ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å‘ä¸Šã®ãŸã‚ã€ç•°å¸¸ãªã‚¢ã‚¯ã‚»ã‚¹ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ¤œå‡ºã—ã¾ã™ï¼š

```typescript
// src/lib/auth/securityMonitor.ts
import { getToken } from './tokenStorage';
import { reportSuspiciousActivity } from '../api/securityApi';

interface ActivityLog {
  timestamp: number;
  action: string;
  ip?: string;
  userAgent?: string;
}

const activityHistory: ActivityLog[] = [];
const MAX_HISTORY_SIZE = 100;

// ã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£ã‚’ãƒ­ã‚°ã«è¨˜éŒ²
export const logActivity = (action: string): void => {
  const log: ActivityLog = {
    timestamp: Date.now(),
    action,
    userAgent: navigator.userAgent,
  };
  
  activityHistory.push(log);
  
  // å±¥æ­´ã‚µã‚¤ã‚ºã‚’åˆ¶é™
  if (activityHistory.length > MAX_HISTORY_SIZE) {
    activityHistory.shift();
  }
  
  // ç•°å¸¸ãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ¤œå‡º
  detectSuspiciousPatterns();
};

// ç•°å¸¸ãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ¤œå‡º
const detectSuspiciousPatterns = (): void => {
  // åŒä¸€ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®çŸ­æ™‚é–“ã§ã®å¤šæ•°å®Ÿè¡Œã‚’æ¤œå‡º
  const last5Minutes = Date.now() - 5 * 60 * 1000;
  const recentActivities = activityHistory.filter(log => log.timestamp > last5Minutes);
  
  // ãƒ­ã‚°ã‚¤ãƒ³è©¦è¡Œå›æ•°ã®ãƒã‚§ãƒƒã‚¯
  const loginAttempts = recentActivities.filter(log => log.action === 'login_attempt');
  if (loginAttempts.length > 5) {
    reportSuspiciousActivity({
      type: 'multiple_login_attempts',
      count: loginAttempts.length,
      details: loginAttempts
    });
  }
  
  // ä»–ã®ç•°å¸¸ãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ¤œå‡ºãƒ­ã‚¸ãƒƒã‚¯...
};
```

### ãƒ‡ãƒ¼ã‚¿ã®æš—å·åŒ–

èªè¨¼æƒ…å ±ã‚’å®‰å…¨ã«ä¿å­˜ã™ã‚‹ãŸã‚ã®æš—å·åŒ–æˆ¦ç•¥ï¼š

```typescript
// src/lib/auth/encryption.ts
// æ³¨æ„: ã“ã‚Œã¯ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã§ã®ç°¡æ˜“çš„ãªæš—å·åŒ–ã§ã‚ã‚Šã€å®Œå…¨ãªå®‰å…¨æ€§ã¯ä¿è¨¼ã•ã‚Œã¾ã›ã‚“
// é«˜åº¦ãªã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãŒå¿…è¦ãªå ´åˆã¯ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ã§ã®ç®¡ç†ã‚’æ¤œè¨ã—ã¦ãã ã•ã„

// AES-GCMæš—å·åŒ–ï¼ˆãƒ–ãƒ©ã‚¦ã‚¶ã®Subtle Cryptoã‚’ä½¿ç”¨ï¼‰
export const encryptData = async (data: string, key: string): Promise<string> => {
  try {
    // ã‚­ãƒ¼ã‚’ãƒãƒƒã‚·ãƒ¥åŒ–ã—ã¦CryptoKeyã«å¤‰æ›
    const encoder = new TextEncoder();
    const keyData = encoder.encode(key);
    const hashBuffer = await crypto.subtle.digest('SHA-256', keyData);
    const cryptoKey = await crypto.subtle.importKey(
      'raw',
      hashBuffer,
      { name: 'AES-GCM', length: 256 },
      false,
      ['encrypt']
    );
    
    // åˆæœŸåŒ–ãƒ™ã‚¯ãƒˆãƒ«ï¼ˆIVï¼‰ã®ç”Ÿæˆ
    const iv = crypto.getRandomValues(new Uint8Array(12));
    
    // ãƒ‡ãƒ¼ã‚¿ã®æš—å·åŒ–
    const encodedData = encoder.encode(data);
    const encryptedBuffer = await crypto.subtle.encrypt(
      { name: 'AES-GCM', iv },
      cryptoKey,
      encodedData
    );
    
    // æš—å·åŒ–ãƒ‡ãƒ¼ã‚¿ã¨IVã‚’çµåˆã—ã¦Base64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰
    const encryptedArray = new Uint8Array(encryptedBuffer);
    const result = new Uint8Array(iv.length + encryptedArray.length);
    result.set(iv);
    result.set(encryptedArray, iv.length);
    
    return btoa(String.fromCharCode(...result));
  } catch (error) {
    console.error('Encryption failed:', error);
    throw new Error('ãƒ‡ãƒ¼ã‚¿ã®æš—å·åŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ');
  }
};

// å¾©å·åŒ–å‡¦ç†
export const decryptData = async (encryptedData: string, key: string): Promise<string> => {
  try {
    // Base64ãƒ‡ã‚³ãƒ¼ãƒ‰ã¨åˆ†é›¢
    const data = new Uint8Array(
      atob(encryptedData).split('').map(char => char.charCodeAt(0))
    );
    const iv = data.slice(0, 12);
    const ciphertext = data.slice(12);
    
    // ã‚­ãƒ¼ã®å‡¦ç†
    const encoder = new TextEncoder();
    const keyData = encoder.encode(key);
    const hashBuffer = await crypto.subtle.digest('SHA-256', keyData);
    const cryptoKey = await crypto.subtle.importKey(
      'raw',
      hashBuffer,
      { name: 'AES-GCM', length: 256 },
      false,
      ['decrypt']
    );
    
    // å¾©å·åŒ–
    const decryptedBuffer = await crypto.subtle.decrypt(
      { name: 'AES-GCM', iv },
      cryptoKey,
      ciphertext
    );
    
    // ãƒ†ã‚­ã‚¹ãƒˆã«ãƒ‡ã‚³ãƒ¼ãƒ‰
    const decoder = new TextDecoder();
    return decoder.decode(decryptedBuffer);
  } catch (error) {
    console.error('Decryption failed:', error);
    throw new Error('ãƒ‡ãƒ¼ã‚¿ã®å¾©å·åŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ');
  }
};
```

## ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

### ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

1. **ãƒˆãƒ¼ã‚¯ãƒ³ã®ä¿å­˜å ´æ‰€**
   - æœ¬ç•ªç’°å¢ƒã§ã¯HTTPOnly Cookieã‚’å„ªå…ˆ
   - XSSå¯¾ç­–ã‚’å¾¹åº•

2. **ãƒˆãƒ¼ã‚¯ãƒ³ã®æœ‰åŠ¹æœŸé™**
   - ã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³ã¯çŸ­ã„æœ‰åŠ¹æœŸé™ï¼ˆ15åˆ†ã€œ1æ™‚é–“ï¼‰
   - ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ã®ä½µç”¨

3. **HTTPSé€šä¿¡ã®å¼·åˆ¶**
   - é–‹ç™ºç’°å¢ƒã§ã‚‚HTTPSã‚’è¨­å®š
   - Secureå±æ€§ä»˜ãCookieã‚’ä½¿ç”¨

4. **CSRFå¯¾ç­–**
   - é©åˆ‡ãªCSRFãƒˆãƒ¼ã‚¯ãƒ³ã®å®Ÿè£…
   - Same-Site Cookieå±æ€§ã®è¨­å®š

### UXã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

1. **ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ã®æ°¸ç¶šæ€§**
   - ã€Œãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ã‚’ä¿æŒã™ã‚‹ã€ã‚ªãƒ—ã‚·ãƒ§ãƒ³
   - ã‚»ãƒƒã‚·ãƒ§ãƒ³å¾©å…ƒã®ä»•çµ„ã¿

2. **ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°**
   - ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ•ãƒ¬ãƒ³ãƒ‰ãƒªãƒ¼ãªã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
   - ãƒªãƒˆãƒ©ã‚¤æ©Ÿèƒ½ã®å®Ÿè£…

3. **ãƒãƒ«ãƒãƒ‡ãƒã‚¤ã‚¹å¯¾å¿œ**
   - ã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†ã®å·¥å¤«
   - ãƒ‡ãƒã‚¤ã‚¹é–“ã§ã®ãƒ­ã‚°ã‚¢ã‚¦ãƒˆé€£æº

## ã¾ã¨ã‚

Reactã‚’ä½¿ã£ãŸãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰èªè¨¼ã¯ã€å˜ãªã‚‹ãƒ­ã‚°ã‚¤ãƒ³ãƒ•ã‚©ãƒ¼ãƒ ã®å®Ÿè£…ã«ã¨ã©ã¾ã‚‰ãšã€ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã€UXã€ä¿å®ˆæ€§ãªã©å¤šãã®å´é¢ã‚’è€ƒæ…®ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

æœ¬è¨˜äº‹ã§è§£èª¬ã—ãŸä»¥ä¸‹ã®ãƒã‚¤ãƒ³ãƒˆã‚’æ„è­˜ã—ã¦å®Ÿè£…ã‚’é€²ã‚ã¾ã—ã‚‡ã†ï¼š

1. èªè¨¼ã¨èªå¯ã®åŸºæœ¬æ¦‚å¿µã‚’ç†è§£ã™ã‚‹
2. ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒªã‚¹ã‚¯ã‚’æŠŠæ¡ã—ã€å¯¾ç­–ã‚’è¬›ã˜ã‚‹
3. ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«é©ã—ãŸèªè¨¼æ–¹å¼ã‚’é¸æŠã™ã‚‹
4. ãƒ†ã‚¹ãƒˆæˆ¦ç•¥ã‚’ç«‹ã¦ã€ä¿¡é ¼æ€§ã‚’ç¢ºä¿ã™ã‚‹
5. èªè¨¼ãƒ‡ãƒ¼ã‚¿ã‚’å®‰å…¨ã«ç®¡ç†ãƒ»æ›´æ–°ã™ã‚‹ä»•çµ„ã¿ã‚’æ•´ãˆã‚‹

ã“ã‚Œã‚‰ã®çŸ¥è­˜ã‚’æ´»ã‹ã—ã¦ã€å®‰å…¨ã§ä½¿ã„ã‚„ã™ã„èªè¨¼ã‚·ã‚¹ãƒ†ãƒ ã‚’æ§‹ç¯‰ã—ã¦ãã ã•ã„ã€‚

## å‚è€ƒãƒªã‚½ãƒ¼ã‚¹

- [Auth0 Documentation](https://auth0.com/docs)
- [OWASP Authentication Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html)
- [React Router Documentation](https://reactrouter.com/en/main)
- [JWT.io](https://jwt.io/)
- [React Query Documentation](https://tanstack.com/query/latest)

## å®Ÿè£…ä¾‹ï¼šèªè¨¼ãƒ•ã‚©ãƒ¼ãƒ 

æœ€å¾Œã«ã€å®Ÿéš›ã®èªè¨¼ãƒ•ã‚©ãƒ¼ãƒ ã®å®Ÿè£…ä¾‹ã‚’è¦‹ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

### ãƒ­ã‚°ã‚¤ãƒ³ãƒ•ã‚©ãƒ¼ãƒ 

```tsx
// src/components/LoginForm.tsx
import { useState } from 'react';
import { useNavigate, useLocation } from 'react-router-dom';
import { useAuth } from '../contexts/AuthContext';

interface LocationState {
  from?: {
    pathname: string;
  };
}

export const LoginForm = () => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [rememberMe, setRememberMe] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  const { login, loading } = useAuth();
  const navigate = useNavigate();
  const location = useLocation();
  
  // ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆå…ƒã‚’å–å¾—ï¼ˆä¿è­·ã•ã‚ŒãŸãƒ«ãƒ¼ãƒˆã‹ã‚‰ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆã•ã‚ŒãŸå ´åˆï¼‰
  const state = location.state as LocationState;
  const from = state?.from?.pathname || '/dashboard';
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError(null);
    
    try {
      await login(email, password, rememberMe);
      navigate(from, { replace: true });
    } catch (err: any) {
      setError(err.message || 'ãƒ­ã‚°ã‚¤ãƒ³ã«å¤±æ•—ã—ã¾ã—ãŸ');
    }
  };
  
  return (
    <div className="login-form-container">
      <h2>ãƒ­ã‚°ã‚¤ãƒ³</h2>
      
      {error && (
        <div className="error-message">{error}</div>
      )}
      
      <form onSubmit={handleSubmit}>
        <div className="form-group">
          <label htmlFor="email">ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹</label>
          <input
            id="email"
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            required
            autoComplete="email"
          />
        </div>
        
        <div className="form-group">
          <label htmlFor="password">ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰</label>
          <input
            id="password"
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            required
            autoComplete="current-password"
          />
        </div>
        
        <div className="form-group checkbox">
          <input
            id="remember-me"
            type="checkbox"
            checked={rememberMe}
            onChange={(e) => setRememberMe(e.target.checked)}
          />
          <label htmlFor="remember-me">ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ã‚’ä¿æŒã™ã‚‹</label>
        </div>
        
        <button
          type="submit"
          disabled={loading}
          className="login-button"
        >
          {loading ? 'ãƒ­ã‚°ã‚¤ãƒ³ä¸­...' : 'ãƒ­ã‚°ã‚¤ãƒ³'}
        </button>
      </form>
      
      <div className="extra-options">
        <a href="/password-reset">ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’ãŠå¿˜ã‚Œã§ã™ã‹ï¼Ÿ</a>
        <a href="/register">ã‚¢ã‚«ã‚¦ãƒ³ãƒˆç™»éŒ²</a>
      </div>
    </div>
  );
};
```

### APIé€šä¿¡éƒ¨åˆ†

```typescript
// src/api/authApi.ts
import axios from 'axios';
import { getToken } from '../lib/auth/tokenStorage';

// APIã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®è¨­å®š
const apiClient = axios.create({
  baseURL: process.env.REACT_APP_API_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

// ãƒªã‚¯ã‚¨ã‚¹ãƒˆæ™‚ã«èªè¨¼ãƒˆãƒ¼ã‚¯ãƒ³ã‚’è¿½åŠ ã™ã‚‹ã‚¤ãƒ³ã‚¿ãƒ¼ã‚»ãƒ—ã‚¿ãƒ¼
apiClient.interceptors.request.use(
  (config) => {
    const token = getToken();
    if (token && config.headers) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
apiClient.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;
    
    // èªè¨¼ã‚¨ãƒ©ãƒ¼ï¼ˆ401ï¼‰ã®å ´åˆã§ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥æœªå®Ÿæ–½ã®å ´åˆ
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;
      
      try {
        // ãƒˆãƒ¼ã‚¯ãƒ³ã®ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ã‚’è©¦ã¿ã‚‹
        const { data } = await apiClient.post('/auth/refresh');
        const { token } = data;
        
        // æ–°ã—ã„ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ä¿å­˜
        setToken(token);
        
        // å…ƒã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å†è©¦è¡Œ
        originalRequest.headers.Authorization = `Bearer ${token}`;
        return apiClient(originalRequest);
      } catch (refreshError) {
        // ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ã«å¤±æ•—ã—ãŸå ´åˆã¯ãƒ­ã‚°ã‚¢ã‚¦ãƒˆ
        // ã“ã“ã§èªè¨¼ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®logoutã‚’å‘¼ã³å‡ºã›ãªã„ï¼ˆå¾ªç’°ä¾å­˜ã«ãªã‚‹ãŸã‚ï¼‰
        // ä»£ã‚ã‚Šã«ã‚«ã‚¹ã‚¿ãƒ ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºè¡Œ
        window.dispatchEvent(new CustomEvent('auth:logout-required'));
        return Promise.reject(refreshError);
      }
    }
    
    return Promise.reject(error);
  }
);

// ãƒ­ã‚°ã‚¤ãƒ³å‡¦ç†
export const loginUser = async (email: string, password: string, rememberMe = false) => {
  try {
    const { data } = await apiClient.post('/auth/login', {
      email,
      password,
      rememberMe,
    });
    return data;
  } catch (error: any) {
    const message = error.response?.data?.message || 'ãƒ­ã‚°ã‚¤ãƒ³ã«å¤±æ•—ã—ã¾ã—ãŸ';
    throw new Error(message);
  }
};

// ãƒ­ã‚°ã‚¢ã‚¦ãƒˆå‡¦ç†
export const logoutUser = async () => {
  try {
    await apiClient.post('/auth/logout');
  } catch (error) {
    console.error('Logout failed:', error);
    // ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¦ã‚‚ãƒˆãƒ¼ã‚¯ãƒ³ã¯ã‚¯ãƒªã‚¢ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ãŸã‚ã€ã‚¨ãƒ©ãƒ¼ã¯å†ã‚¹ãƒ­ãƒ¼ã—ãªã„
  }
};

// ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã®å–å¾—
export const fetchUserProfile = async () => {
  try {
    const { data } = await apiClient.get('/users/me');
    return data;
  } catch (error: any) {
    if (error.response?.status === 401) {
      return null; // èªè¨¼ã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯é™ã‹ã«å¤±æ•—
    }
    throw error;
  }
};

// ãƒˆãƒ¼ã‚¯ãƒ³ã®ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥
export const refreshToken = async () => {
  const { data } = await apiClient.post('/auth/refresh');
  return data;
};
```

## ãƒ¢ãƒã‚¤ãƒ«é€£æºæ™‚ã®è€ƒæ…®ç‚¹

Webã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¨ãƒ¢ãƒã‚¤ãƒ«ã‚¢ãƒ—ãƒªã‚’ä½µç”¨ã™ã‚‹å ´åˆã®èªè¨¼é€£æºã«ã¤ã„ã¦è€ƒæ…®ã™ã¹ãç‚¹ã‚‚ç´¹ä»‹ã—ã¾ã™ã€‚

### ãƒ‡ã‚£ãƒ¼ãƒ—ãƒªãƒ³ã‚¯å¯¾å¿œ

ãƒ¢ãƒã‚¤ãƒ«ã‚¢ãƒ—ãƒªã¨ã®é€£æºã«ã¯ã€ãƒ‡ã‚£ãƒ¼ãƒ—ãƒªãƒ³ã‚¯ã‚’æ´»ç”¨ã—ã¾ã™ï¼š

```typescript
// src/utils/deepLinkHandler.ts
export const handleDeepLink = () => {
  // URLã‹ã‚‰ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å–å¾—
  const urlParams = new URLSearchParams(window.location.search);
  const token = urlParams.get('token');
  const action = urlParams.get('action');
  
  if (token && action === 'auth') {
    // ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ä¿å­˜
    setToken(token);
    
    // URLãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å‰Šé™¤ï¼ˆã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¸Šã®ç†ç”±ã‹ã‚‰ï¼‰
    window.history.replaceState({}, document.title, window.location.pathname);
    
    // èªè¨¼çŠ¶æ…‹ã‚’æ›´æ–°ã™ã‚‹ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºè¡Œ
    window.dispatchEvent(new CustomEvent('auth:token-received'));
    
    return true;
  }
  
  return false;
};

// èµ·å‹•æ™‚ã«å‘¼ã³å‡ºã™
export const initDeepLinkHandling = () => {
  // åˆå›ã®ãƒã‚§ãƒƒã‚¯
  handleDeepLink();
  
  // å±¥æ­´å¤‰æ›´ã‚¤ãƒ™ãƒ³ãƒˆã§ã‚‚å‡¦ç†
  window.addEventListener('popstate', handleDeepLink);
};
```

### QRã‚³ãƒ¼ãƒ‰èªè¨¼

ã‚¹ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒ³ã§ã®QRã‚³ãƒ¼ãƒ‰ã‚¹ã‚­ãƒ£ãƒ³ã«ã‚ˆã‚‹èªè¨¼é€£æºï¼š

```tsx
// src/components/QRCodeAuth.tsx
import { useEffect, useState } from 'react';
import QRCode from 'qrcode.react';
import { nanoid } from 'nanoid';
import { useAuth } from '../contexts/AuthContext';

export const QRCodeAuth = () => {
  const [sessionId, setSessionId] = useState('');
  const [status, setStatus] = useState('waiting');
  const { login } = useAuth();
  
  // ã‚»ãƒƒã‚·ãƒ§ãƒ³IDã®ç”Ÿæˆ
  useEffect(() => {
    const id = nanoid();
    setSessionId(id);
    
    // WebSocketã¾ãŸã¯ãƒãƒ¼ãƒªãƒ³ã‚°ã§èªè¨¼çŠ¶æ…‹ã‚’ç¢ºèª
    const checkInterval = setInterval(async () => {
      try {
        const response = await fetch(`/api/auth/qr-status?sessionId=${id}`);
        const data = await response.json();
        
        if (data.status === 'authorized') {
          // èªè¨¼æˆåŠŸ
          clearInterval(checkInterval);
          setStatus('authorized');
          
          // ãƒˆãƒ¼ã‚¯ãƒ³ã¨ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚’å–å¾—
          login(data.token, data.user);
        } else if (data.status === 'scanned') {
          setStatus('scanned');
        }
      } catch (error) {
        console.error('QR auth check failed:', error);
      }
    }, 2000);
    
    return () => clearInterval(checkInterval);
  }, [login]);
  
  return (
    <div className="qr-auth-container">
      <h3>ã‚¹ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒ³ã§ãƒ­ã‚°ã‚¤ãƒ³</h3>
      
      {status === 'waiting' && (
        <>
          <p>ã‚¹ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒ³ã§QRã‚³ãƒ¼ãƒ‰ã‚’ã‚¹ã‚­ãƒ£ãƒ³ã—ã¦ãã ã•ã„</p>
          <div className="qr-code">
            <QRCode
              value={`${process.env.REACT_APP_MOBILE_URL}/auth-scan?sessionId=${sessionId}`}
              size={200}
              level="H"
            />
          </div>
        </>
      )}
      
      {status === 'scanned' && (
        <p>ã‚¹ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒ³ã§ã®èªè¨¼ã‚’å®Œäº†ã—ã¦ãã ã•ã„</p>
      )}
      
      {status === 'authorized' && (
        <p>èªè¨¼æˆåŠŸï¼ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆã—ã¾ã™...</p>
      )}
    </div>
  );
};
```

## ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£æŸ»ã®ãƒã‚¤ãƒ³ãƒˆ

ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚’å¼·åŒ–ã™ã‚‹ãŸã‚ã€å®šæœŸçš„ãªç›£æŸ»ã‚’è¡Œã„ã¾ã—ã‚‡ã†ã€‚ä»¥ä¸‹ã®ãƒã‚¤ãƒ³ãƒˆã‚’ç¢ºèªã™ã‚‹ã“ã¨ã‚’ãŠå‹§ã‚ã—ã¾ã™ï¼š

1. **èªè¨¼ãƒ•ãƒ­ãƒ¼ã®å®Œå…¨æ€§**
   - ãƒˆãƒ¼ã‚¯ãƒ³ã®æ¼æ´©ãƒªã‚¹ã‚¯ã®ç¢ºèª
   - ã‚»ãƒƒã‚·ãƒ§ãƒ³å›ºå®šæ”»æ’ƒã¸ã®å¯¾ç­–

2. **ãƒˆãƒ¼ã‚¯ãƒ³ç®¡ç†**
   - å®‰å…¨ãªä¿å­˜æ–¹æ³•ã®æ¤œè¨¼
   - é©åˆ‡ãªæœ‰åŠ¹æœŸé™è¨­å®š

3. **å…¥åŠ›æ¤œè¨¼**
   - ã™ã¹ã¦ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼å…¥åŠ›ã®æ¤œè¨¼
   - SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³ãªã©ã®å¯¾ç­–

4. **ã‚¨ãƒ©ãƒ¼å‡¦ç†**
   - ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£æƒ…å ±ã®æ¼æ´©é˜²æ­¢
   - é©åˆ‡ãªã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸

5. **ä¾å­˜é–¢ä¿‚**
   - ä½¿ç”¨ã—ã¦ã„ã‚‹ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®è„†å¼±æ€§ãƒã‚§ãƒƒã‚¯
   - å®šæœŸçš„ãªæ›´æ–°

## æœ€å¾Œã«

èªè¨¼ã¯ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã®è¦ã§ã™ã€‚æœ¬è¨˜äº‹ã§è§£èª¬ã—ãŸå†…å®¹ã‚’å®Ÿè·µã—ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå®‰å¿ƒã—ã¦åˆ©ç”¨ã§ãã‚‹ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’æ§‹ç¯‰ã—ã¦ãã ã•ã„ã€‚

ã¾ãŸã€ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã¯å¸¸ã«é€²åŒ–ã—ã¦ã„ã¾ã™ã€‚æœ€æ–°ã®è„…å¨ã‚„å¯¾ç­–ã«ã¤ã„ã¦å®šæœŸçš„ã«æƒ…å ±ã‚’ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆã™ã‚‹ã“ã¨ã‚‚é‡è¦ã§ã™ã€‚

èªè¨¼å®Ÿè£…ã«é–¢ã™ã‚‹ã”è³ªå•ã‚„ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ãŒã‚ã‚Œã°ã€ã‚³ãƒ¡ãƒ³ãƒˆæ¬„ã§ãŠå¾…ã¡ã—ã¦ã„ã¾ã™ã€‚